#!/usr/bin/python

# =============================================================================
#
#    MPlayer adapter for Remuco
#    Copyright (C) 2009 Ronald Oquendo Munoz
#
#    Remuco - A remote control system for media players.
#    Copyright (C) 2006-2009 Oben Sonne <obensonne@googlemail.com>
#
#    This file is part of Remuco.
#
#    Remuco is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Remuco is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Remuco.  If not, see <http://www.gnu.org/licenses/>.
#
# =============================================================================

# Some remote control related documentation for MPlayer is available at
# http://www.mplayerhq.hu/DOCS/tech/slave.txt
# To parse the status line, read
# http://www.mplayerhq.hu/DOCS/HTML/en/faq.html#id2734829

"""MPlayer adapter for Remuco, implemented as an executable script."""

import os
import os.path
import gobject
from time import sleep

import remuco
from remuco import log


class MplayerAdapter(remuco.PlayerAdapter):

    def __init__(self):

        remuco.PlayerAdapter.__init__(self, "MPlayer")

        self.cmdfifo = os.path.join(self.config.cache_dir, "cmdfifo")
        self.cmdfifo = self.config.get_custom("mplayer-cmdfifo", self.cmdfifo)

        self.statusfifo = os.path.join(self.config.cache_dir, "statusfifo")
        self.statusfifo = self.config.get_custom("mplayer-statusfifo", self.statusfifo)

        # ensure config is written:
        self.config.set_custom("mplayer-cmdfifo", self.cmdfifo)
        self.config.set_custom("mplayer-statusfifo", self.statusfifo)

        # file descriptors
        self.fd_cmdfifo = 0
        self.fd_statusfifo = 0

        # gobject's watch: read from mplayer using statusfifo
        self.watch_id = None

    def start(self):

        remuco.PlayerAdapter.start(self)

        if not(os.path.exists(self.cmdfifo)):
            os.mkfifo(self.cmdfifo)

        log.debug("creating cmdfifo and waiting for mplayer to read it")
        self.fd_cmdfifo = os.open(self.cmdfifo, os.O_WRONLY)

        if os.path.exists(self.statusfifo):
            self.fd_statusfifo = os.open(self.statusfifo, os.O_RDONLY)

            self.watch_id = gobject.io_add_watch(self.fd_statusfifo,
                gobject.IO_IN | gobject.IO_ERR | gobject.IO_HUP,
                self.__inputevent)
        else:
            log.warning("could not find statusfifo. Remuco's client "
                " will not be able to retrieve information from the player.\n"
                "Make sure mplayer's output streams include " + self.statusfifo)

        log.debug("starting mplayer adapter")

    def stop(self):

        remuco.PlayerAdapter.stop(self)

        # maybe this would look prettier in a try/catch block?
        if self.fd_cmdfifo != 0:
            os.close(self.fd_cmdfifo)
        if self.fd_statusfifo != 0:
            os.close(self.fd_statusfifo)

        if self.watch_id is not None:
            gobject.source_remove(self.watch_id)

        log.debug("stopping mplayer adapter")

    #def poll(self):

        #import random

        #volume = random.randint(0,100)
        #self.update_volume(volume)

        #playing = random.randint(0,1)
        #if playing:
        #    self.update_playback(remuco.PLAYBACK_PLAY)
        #else:
        #    self.update_playback(remuco.PLAYBACK_PAUSE)

    # =========================================================================
    # control interface
    # =========================================================================

    def ctrl_toggle_playing(self):
        self.__command('pause\n')

    def ctrl_toggle_fullscreen(self):
        self.__command('vo_fullscreen\n')

    def ctrl_next(self):
        self.__command('pt_step 1\n')

    def ctrl_previous(self):
        self.__command('pt_step -1\n')

    def ctrl_volume(self, direction):
        self.__command('volume %s\n' % direction)

    def ctrl_seek(self, direction):
        self.__command('seek %s0\n' % direction)

    # =========================================================================
    # request interface
    # =========================================================================

    #def request_playlist(self, client):

    #    self.reply_playlist_request(client, ["1", "2"],
    #            ["Joe - Joe's Song", "Sue - Sue's Song"])

    # ...

    # =========================================================================
    # internal methods
    # =========================================================================

    def __command(self, cmd):
        """Write a command to the MPlayer FIFO and handle errors."""

        try:
            os.write(self.fd_cmdfifo, cmd)
        except OSError, e:
            log.warning("FIFO to MPlayer broken (%s)", e)
            self.manager.stop()

    def __read_fifo(self, fd):
        """Read from a FIFO and handle errors."""
        try:
            str = os.read(fd, 100) #magic buflength number
            return str
        except OSError, e:
            log.warning("FIFO from MPlayer broken (%s)", e)
            self.manager.stop()

    def __inputevent(self, fd, condition):
        if condition == gobject.IO_IN:
            # read from fd (fd is self.fd_statusfifo)
            status_str = self.__read_fifo(fd)

            # TODO parse the string

            # set global string to be read on poll()
            return True
        else:
            log.error("statusfifo read error")
            self.watch_id = None
            self.manager.stop()
            return False



# =============================================================================
# main (example startup using remuco.Manager)
# =============================================================================

if __name__ == '__main__':

    pa = MplayerAdapter() # create the player adapter
    mg = remuco.Manager(pa) # pass it to a manager
    mg.run() # run the manager (blocks until interrupt signal)

